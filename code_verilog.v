1module BasicFsm( 2 //-----------------------------------------------------------3 // Inputs 4 //-----------------------------------------------------------5 input wire Clock, 6 input wire Reset, 7 input wire A, 8 input wire B, 9 //-----------------------------------------------------------10 11 //-----------------------------------------------------------12 // Outputs 13 //-----------------------------------------------------------14 output wire Output1, 15 output wire Output2, 16 output reg[2:0] Status 17 //-----------------------------------------------------------18 ); 19 20//-------------------------------------------------------------------21// State Encoding 22//-------------------------------------------------------------------23localparam STATE_Initial = 3’d0, 24 STATE_1 = 3’d1, 25 STATE_2 = 3’d2, 26 STATE_3 = 3’d3, 27 STATE_4 = 3’d4, 28 STATE_5_PlaceHolder = 3’d5, 29 STATE_6_PlaceHolder = 3’d6, 30 STATE_7_PlaceHolder = 3’d7; 31//-------------------------------------------------------------------32 33//-------------------------------------------------------------------34// State reg Declarations 35//-------------------------------------------------------------------36reg[2:0] CurrentState; 37reg[2:0] NextState; 38//-------------------------------------------------------------------39 40//-------------------------------------------------------------------41// Outputs 42//-------------------------------------------------------------------43// 1-bit outputs 44assign Output1 = (CurrentState == STATE_1) | (CurrentState == STATE_2); 45assign Output2 = (CurrentState == STATE_2); 46 47// multi-bit outputs 48always@( * ) begin 49 Status = 3’b000; 50 case (CurrentState) 51 STATE_2: begin 52 Status = 3’b010; 53 end 54 STATE_3: begin 55 Status = 3’b011; 56 end 57 endcase 58end 59//-------------------------------------------------------------------15Program 24 The complete FSM (part 2) from Figure 1 5 1 //-------------------------------------------------------------------2 // Synchronous State-Transition always@(posedge Clock) block 3 //-------------------------------------------------------------------4 always@(posedge Clock) begin if (Reset) CurrentState <= STATE_Initial; else CurrentState <= NextState; 6 7 end 8 //-------------------------------------------------------------------14 9 10 //-------------------------------------------------------------------11 // Conditional State-Transition always@( * ) block 12 //-------------------------------------------------------------------13 always@( * ) begin NextState = CurrentState; 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 case (CurrentState) STATE_Initial: begin NextState = STATE_1; end STATE_1: begin if (A & B) NextState = STATE_2; end STATE_2: begin end STATE_3: begin if (A) NextState = STATE_3; if (!A & B) NextState = STATE_Initial; else if (A & !B) NextState = STATE_4; end STATE_4: begin end STATE_5_PlaceHolder: begin NextState = STATE_Initial; end STATE_6_PlaceHolder: begin NextState = STATE_Initial; end STATE_7_PlaceHolder: begin NextState = STATE_Initial; end endcase 40 41 end 42 //-------------------------------------------------------------------43 44 endmodule 45 //-------------------------------------------------------------------